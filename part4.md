## Классы

**Класс** - основа объектно-ориентированного программирования. Классы описывают внутреннюю структуру и поведение объектов, с помощью которых описывается решение задачи. Использовать ООП - это значит разработать систему классов, описать их взаимодействие и тем самым получить запись решения.

С точки зрения программиста, классы содержат данные (поля) и функции (методы).

### Анатомия класса

Содержимое класса обычно находится в специальных разделах, разграничивающих доступ. Существуют три ключевых слова (**private** - закрытый, **protected** - защищенный, **public** - открытый), которые используются для обозначения начала раздела. Данные класса стараются закрыть, спрятать от пользователей класса, а доступ к ним осуществляется через открытые методы.


Обычно используют заголовочные файлы, в которые помещают описание класса. Рассмотрим пример класса **Counter** (счетчик).

`Counter.h`

```c++
#ifndef _COUNTER_H
#define _COUNTER_H_

typedef unsigned int count_t;

class Counter
{
private:
  count_t count;
public:
  void reset();
  void inc();
  count_t get() const;
};
#endif
```

Реализация методов класса обычно размещается в .cpp файле:

`Counter.cpp`

```c++
#include "Counter.h"

void Counter::reset()
{
   count=0;
}
void Counter::inc()
{
   count++;
}
count_t Counter::get() const
{
   return count;
}
```

В проекте, где необходио использвать класс **Counter**, выполняется включение заголовочного файла в те модули, которые используют класс, а далее выполняется компоновка с откомпилированной версией `Counter.cpp`.

Можно использовать  следующую команду при работе с `g++` ( предполагается, что в **main** основная программа):

```
g++ -o app main.cpp Counter.cpp
```

Основное преимущество при использовании классов заключается в возможности отдельно разрабатывать состав и поведение сложных объектов, не изменяя сценарий их использования.

### Создание экземпляров класса

Экземпляры класса (объекты) создаются различными способами. Если мы хотим создать их в стеке, подобно обычным автоматическим переменным, то пишем так:

```c++
int main()
{
   Counter pass;
   ...
}
```

Также создаются и массивы объектов:

```c++
int main()
{
   Counter pass[10];
   ...
}
```

Наиболее популярный способ - создание динамических объектов (в куче):

```c++
int main()
{
   Counter *pass=new Counter;     // одиночный объект
   Counter *zoo=new Counter[10];  // массив из объектов
   ...
}
```
При создании динамических объектов предполагается вызов **delete** для освобождения динамической памяти:

```c++
   ...
   delete pass;
   delete[] zoo;
   ...

```

### Специальные члены класса

К специальным членам класса можно отнести

- конструкторы
- деструкторы
- указатель **this**

**Конструктор** - это метод класса, который вызывается при создании объекта, сразу же после выделения объекту памяти. Основное назначение этого метода - провести инициализацию полей класса и выделить дополнительную память под внутренние переменные или массивы.

Конструкторы бывают:

- **По-умолчанию** - это конструктор без параметров в случае описания и неявный конструктор, назначаемый самой программой в случае отсутствия явного описания (как в класса **Counter** выше)
- **Обычный** - конструктор с параметрами.
- **Копирующий** - создающий копию имеющегося объекта.
- **Перемещающий** - выполняющий действия по перемещению данных их одного объекта в другой (С++11).

В стандарте С++11 появилась возможность инициализировать поля класса непосредственно при объявлении:

```c++
class Counter
{
private:
  count_t count=0;
public:
  ...
};
#endif
```

При наличии нескольких полей, при инициализации можно ссылаться на значенения ранее инициализированных полей:

```c++
class A
{
private:
  count_t count1=0;
  count_t count2=count_1+1;
  count_t count3=count_2+1;
public:
  ...
};
#endif
```

При этом сохраняется возможность иницализации через конструкторы, что будет иметь больший приоритет при наличии двух способов.

Рассмотрим различные виды конструкторов на примере строкового класса:

```c++
class String
{
private:
	char *buf;  // поле для хранения символьного массива
	size_t len;     // длина строки
public:
    String(size_t);   // конструктор с параметром числового типа
    String(const char* =nullptr);// конструктор с параметром-указателем
	String(const String&); // конструктор копирования
	String(String&&);  // конструктор перемещения
	...
};
```

Конструктором по-умолчанию здесь выступает второй конструктор, поскольку у указателя есть значение **nullptr**, присваиваемое по-умолчанию.

Реализация конструкторов:


```c++
String::String(size_t len) 
{
	this->len = len;
	buf = new char[len];
	*buf = 0;
}

String::String(const char * str) :String(strlen(str) + 1)
{
	strcpy(buf, str);
}
String::String(const String& s) : String(s.len)
{
	strcpy(buf, s.buf);
}
String::String(String && s)
{
	buf = s.buf;
	len = s.len;
	s.buf = nullptr;
	s.len = 0;
}
```

При реализации конструкторов 2 и 3 использовалась возможность, введенная в стандарте С++11, а именно: **явный вызов конструкторов**, то есть операция выделения памяти находится в первом конструкторе и мы вызываем его явно из других.

Перемещающий конструктор выполняет перенос данных без копирование, то есть захватывает значение указателя, обнуляя оригинал. 

**Деструктор** класса - это функция, которая вызывается автоматически при разрушении объекта (или окончания времени жизни). Самое распространенное назначение этого метода - освобождение выделенной в конструкторе динамической памяти:

```c++
class String
{
...
public:
...
    ~String();
...
};

String::~String()
{
	delete[]buf;
}
```

Указатель **this** позволяет объекту узнать свой адрес или сослаться на члены класса в случае неоднозначности имен-параметров:

```c++
String(int len)
{
   this->len=len; // уточняем имена
}
...
String& get()
{
   return *this; // возвращаем ссылку на себя
}   
```




